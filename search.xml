<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F07%2F05%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[总要学点新东西嘛，所以从头开始捡Java…QwQ 以下资料出自于实验楼 泛型 泛型即参数化类型，也就是说数据类型变成了一个可变的参数，在不使用泛型的情况下，参数的数据类型都是写死了的，使用泛型之后，可以根据程序的需要进行改变。 定义泛型的规则： 只能是类类型，不能是简单数据类型 泛型参数可以有多个 可以用使用 extends 语句或者 super 语句 如&lt;T extends superClass&gt;表示类型的上界，T 只能是 superClass 或其子类， &lt;K super childClass&gt;表示类型的下界，K 只能是 childClass 或其父类。 可以是通配符类型，比如常见的 Class&lt;?&gt; 定义泛型类12345678910111213141516171819202122232425262728293031323334353637383940/*使用T代表类型，无论何时都没有比这更具体的类型来区分它。如果有多个类型参数，我们可能使用字母表中T的临近的字母，比如S。*/class Test&lt;T&gt; &#123; private T ob; /* 定义泛型成员变量，定义完类型参数后，可以在定义位置之后的方法的任意地方使用类型参数，就像使用普通的类型一样。 注意，父类定义的类型参数不能被子类继承。 */ //构造函数 public Test(T ob) &#123; this.ob = ob; &#125; //getter 方法 public T getOb() &#123; return ob; &#125; //setter 方法 public void setOb(T ob) &#123; this.ob = ob; &#125; public void showType() &#123; System.out.println("T的实际类型是: " + ob.getClass().getName()); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; // 定义泛型类 Test 的一个Integer版本 Test&lt;Integer&gt; intOb = new Test&lt;Integer&gt;(88); intOb.showType(); int i = intOb.getOb(); System.out.println("value= " + i); System.out.println("----------------------------------"); // 定义泛型类Test的一个String版本 Test&lt;String&gt; strOb = new Test&lt;String&gt;("String!"); strOb.showType(); String s = strOb.getOb(); System.out.println("value= " + s); &#125;&#125; emmm感觉泛型就是一个不用考虑属性类型的一种东西？比如写个比较大小的函数就可以不用考虑变量是什么属性了，像ArrayList。]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 将带界面的py打包成Mac能用的app]]></title>
    <url>%2F2018%2F12%2F30%2Fpython3-%E6%89%93%E5%8C%85%E6%88%90Mac%E8%83%BD%E7%94%A8%E7%9A%84app%2F</url>
    <content type="text"><![CDATA[使用修改过的py2app打包步骤： 创建一个文件夹 $mkdir FileName 创建一个virtualenv环境 $virtualenv venv $. venv/bin/activate 将要打包的py放到上面建的文件夹中（我没试过打包多个py文件，因为我就写了个小的试试手） 安装修改过的py2app 1$ pip install -U git+https://github.com/metachris/py2app.git@master 创建setup.py文件 $py2app --make-setup filename.py 创建应用 $python3 setup.py py2app -A 完成！app在dist子文件夹中 参考：https://www.jianshu.com/p/afb6b2b97ce9]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm可以运行但无法debug]]></title>
    <url>%2F2018%2F11%2F29%2FPycharm%E5%8F%AF%E4%BB%A5%E8%BF%90%E8%A1%8C%E4%BD%86%E6%97%A0%E6%B3%95debug%2F</url>
    <content type="text"><![CDATA[pycharm未为允许联网。 建立了一个与python自带的文件同名的文件。 （我建了一个select.py之后就不得安宁，改了就好了。真的很心累]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安利一个Mac的翻墙app]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%AE%89%E5%88%A9%E4%B8%80%E4%B8%AAMac%E7%9A%84%E7%BF%BB%E5%A2%99app%2F</url>
    <content type="text"><![CDATA[强行安利一个付费翻墙的app啊！只要你的网好，就超好用的。 “Wise VPN” 不是很贵，一季35RMB而已。 Wise涨价了👋 ……最后还是用了小飞机……]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQLite3在python3中的基础用法]]></title>
    <url>%2F2018%2F06%2F17%2FSQLite3%E5%9C%A8python3%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[创建/连接数据库123import sqlite3conn = sqlite3.connect('example.db') cursor = conn.cursor() 建立一张叫user的表 1cursor.execute('create table user(id varchar(20) primary key, name verchar(20), password verchar(20), rights int)') 插入行12345cursor.execute(r"insert into user values ('A00001', 'Adam', 'A00001', 0)")cursor.execute(r"insert into user values ('A00002', 'Bart', 'A00002', 2)")cursor.execute(r"insert into user values ('A00003', 'Lisa', 'A00003', 1)")mess = [a, b, c, d]cursor.execute(r"insert into user values (?, ?, ?, ?)", mess) 查询123456t = cursor.execute('select * from user where user.name!="Lisa"') for row in t: print(row)# 输出：# ('A00001', 'Adam', 'A00001', 0)# ('A00002', 'Bart', 'A00002', 2) 修改了表之后要commit1conn.commit() 做完了你要做的要close12cursor.close()conn.close() 修改数据1cursor.execute("update user set name=? where id=?", ('Maya', id)) 删除一行1cursor.execute('delete from user where id=?', (id, )) 更新表1cursor.execute("alter table table_name add clum type") 说明:ALTER TABLE和SQLite SQLite对使用ALTER TABLE执行的操作有所限制。最重要的一个限制是，它不支持使用ALTER TABLE定义主键和外键，这些必须在最初创建表 时指定。 通配符最常使用的通配符是百分号(%)。在搜索串中，%表示任何字符出现任意次数。 12cursor.execute("select * from user where name like 'H%'")cursor.execute("select * from doc where name like ? and new=1", (name, )) 我用pycharm建的数据库不知道为什么是只读的，用sqlitestudio建的就没什么问题。]]></content>
      <tags>
        <tag>python</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2018%2F06%2F09%2FDjango%2F</url>
    <content type="text"><![CDATA[当初没有持之以恒的用Django搭博客的结果就是，换个时间学。 溜了溜了。]]></content>
      <tags>
        <tag>生活</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉迷游戏]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%B2%89%E8%BF%B7%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[最近沉迷模拟人生……过两天还有操作系统要考，怕不是凉了呀。 不过捏脸是真的很好玩……]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git@github.com: Permission denied (publickey)]]></title>
    <url>%2F2018%2F05%2F27%2Fgit%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[遇到Error: git@github.com: Permission denied (publickey).如何解决： ssh-keygen -t rsa -b 4096 -C &quot;yourcount@example.com&quot; 生成新的密匙 eval &quot;$(ssh-agent -s)&quot; 添加密匙到ssh-agent ssh-add -K ~/.ssh/id_rsa 添加生成的SSH key到ssh-agent 把id_rsa.pub里的复制上git的ssh的key里就好了。 Windows下可以用xclip -sel c ~/.ssh/id_rsa.pub复制到剪贴板。 运行完以上命令，重启终端！！！ 越来越感觉能否解决这个问题要靠玄学……而且完全不明白为什么隔几天就会出现，崩溃。 2019.7.5： 以上方法无法解决该问题时，可以尝试改_config.yml文件里的deploy。 把`git@github.com:yourname/yourname.github.io.git`改成 https://yourname:yourpassword@github.com/yourname/yourname.github.io.git 也不一定保证成功¯_(ツ)_/¯真的很玄学了，也不知道这次能撑多久。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行家算法]]></title>
    <url>%2F2018%2F05%2F27%2F%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法目的：预防死锁 数据结构假设有m个资源，n个进程。 可利用资源数组Available[m]，Availabe[i]为i类资源现可用的数目； 最大需求矩阵Max[n*m]，Max[i,j]为进程i需要j资源的最大数目； 分配矩阵Allocation[n*m]，Allocation[i,j]为进程i当前已分配到j资源的数目； 需求矩阵Need[n*m]，Need[i,j]为进程i还需要多少j资源才能完成。 银行家算法 找到一个所需的资源不大于现有资源的进程； 系统进行试探，把资源分配给该进程，更新Available、Allocation、Need数组； 执行安全性算法。 安全性算法设置两个数组，work和finish。work = Available，finish[i] = 0。 从进程集合中找到一个能满足以下条件的进程： finish[i] = 0 Need[i,*] &lt;= work[*] 找到进程i获得资源后可顺利执行，直至完成，并释放分配给它的资源，执行以下步骤： work[j] = work[j] + Allocation[i,j] finish[i] = 1 go to step 1 如果finish全为1则处于安全状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107Available = []Max = []Allocation = []Need = []def find_i(finish, ne, work): for i in range(len(finish)): flag = 0 # 记录每个进程可被满足资源的数量 for j in range(len(work)): if finish[i] == 0: if work[j] &lt; ne[i][j]: continue else: flag += 1 if flag == len(work): # 如果全都满足则可以运行该进程 return i return -1def safety(av, al, ne, choice): work = av[:] finish = [0] * m list = [] while True: i = find_i(finish, ne, work) if i != -1: for j in range(len(work)): work[j] = work[j] + al[i][j] finish[i] = 1 list.append(i) else: if len(finish) == len(tuple(finish)) and finish[0] == 1: if choice == 0: print('该时刻存在的安全序列:', list) return 1 else: return list else: return 0if __name__ == '__main__': f = open('银行家.txt', 'r') lines = f.readlines() m = len(lines) - 1 # 进程数量 # m = int(input('输入进程数量:')) Max = [[]] * m Allocation = [[]] * m Need = [[]] * m # n = int(input('输入资源数量:')) print(lines[0]) lines[0] = list(map(lambda x: int(x), lines[0].split())) n = len(lines[0]) # 资源数量 Available = lines[0] # for i in range(n): # # Available.append(int(input('输入第'+str(i+1)+'个资源的数量:'))) # for j in range(m): # Max[j].append(int(input('输入第'+str(j+1)+'个进程对该资源的最大需求:'))) # Allocation[j].append(int(input('输入第'+str(j+1)+'个进程已分配到的该资源:'))) # Need[j].append(int(input('输入第'+str(j+1)+'个进程还需多少该资源才能完成:'))) lines = lines[1:] for i in range(len(lines)): lines[i] = list(map(lambda x: int(x), lines[i].split())) Max[i] = lines[i][:n] Allocation[i] = lines[i][n:2*n] Need[i] = lines[i][2*n:] for i in range(n): a = 0 for j in range(m): a += Allocation[j][i] Available[i] -= a print(Available) list = [] # 安全序列 while len(list) &lt; m or not list: a = int(input('输入请求资源还是直接输出安全序列？')) if a == 0: flag = 1 request = [int(i) for i in input('输入请求资源的进程及资源的数量:').split()] i = request[0] k = request[1:] # 该进程对所有资源对需求 av = Available[:] al = Allocation[:] ne = Need[:] for j in range(n): if k[j] &lt;= Need[i][j] and k[j] &lt;= Available[j]: av[j] -= k[j] al[i][j] += k[j] ne[i][j] -= k[j] # print(av) else: print('没有足够的资源!') flag = 0 if safety(av, al, ne, 0) and flag: Allocation = al Available = av Need = ne list.append(i) print(list) else: print('不能分配！') else: list = safety(Available, Allocation, Need, 1) print(list) 程序中读取的文本内容： 12345610 5 77 5 3 0 1 0 7 4 33 2 2 2 0 0 1 2 29 0 2 3 0 2 6 0 02 2 2 2 1 1 0 1 14 3 3 0 0 2 4 3 1]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[目标：通过python模拟终端下的创建/删除文件/文件夹、显示该路径下内容、切换路径、tree等命令。 该代码模拟的是Unix下的superblock和inode进行外存的分配与回收。 inode至少包含如下信息： inode 编号 用来识别文件类型，以及用于 stat C 函数的模式信息 文件的链接数目 属主的 UID 属主的组 ID (GID) 文件的大小 文件所使用的磁盘块的实际数目 最近一次修改的时间 最近一次访问的时间 最近一次更改的时间 代码细节： 包含的命令： ls: 显示当前目录下的所有文件 mkdir a: 创建名称为a的目录 mk a 1000: 创建名称为a的、大小为1000字节的文件 tree: 以树的形式显示当前目录下的文件及目录（对不齐） rm a: 移除名称为a的文件/目录（若目录下不为空则无法删除） 代码中inode包含三个直接索引，一级索引，二级索引和三级索引。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402import mathimport time# block = [] # 1已用，-1未用inode_table = []# root = []now = [] # 当前路径# File = &#123;&#125; # key是文件名，value是inode编号，就是inode_table里的索引位置class INode(object): # 每个文件只有一个inode def __init__(self, type): self.id = -1 # table中的index self.type = type # 文件是0，目录是1 self.blo = [] self.time = -1 self.size = 0 self.file = &#123;&#125;class SuperBlock(object): def __init__(self): self.table = [] # 存block中空的下标 self.unused_inode = -1 self.unused_block = -1 self.used_inode = 0 self.used_block = 0 def initial(self, num): # 初始化table sup_tab = self.table self.unused_inode = num self.unused_block = num for i in range(int(math.ceil(num / 10))): sup_tab.append(10) sup_tab.append([10 * i + j for j in range(9)]) sup_tab[-1].append([]) sup_tab = sup_tab[-1][-1]# 左孩子是该路径节点下的文件，右孩子是该结点的同级文件class Tree(object): def __init__(self, date, num, left=None, right=None): self.inode_num = num self.parent = None self.date = date self.left = left self.right = right self.level = 0def depth(t): if t is not None: lDepth = depth(t.left) rDepth = depth(t.right) return max(lDepth, rDepth) + 1 else: return 0def preorder(t): if t is None: return else: print((t.level)*' '+'|', end='') print('---', t.date) preorder(t.left) preorder(t.right)def distribute_block(): # print(sup.table) if sup.table[0] == 1: # 当前只剩一块（存下一组的地址），将此块分出去，存的地址覆盖 fore = sup.table[-1][-1][-1][0] - 1 # fore是被分出去的块号 sup.table = sup.table[-1][0] else: fore = sup.table[-1].pop(0) # print(fore) sup.table[0] -= 1 return foredef add_date_block(k, i): fore = distribute_block() k[-1].append(fore) # block[k[0]].append(fore) i.blo.append(fore)def add_index_block(a, i, j): index_block = distribute_block() # 申请新的块作为索引块 fore = distribute_block() k = [fore] for kk in range(j-1): k = list(k) a.append([index_block, k]) # block[index_block] = [fore] i.blo.append(fore)def add_tree(name, id): global now if now.left is None: # 当前路径有其他文件 # print(now.left.date) a = Tree(name, id) now.left = a a.parent = now a.level = now.level + 1 else: last = now n = now.left while n is not None: # print(last, n) last = n n = n.right a = Tree(name, id) last.right = a a.parent = now a.level = now.level + 1def distribute(i): if len(inode) &lt; 3: # 直接 fore = distribute_block() inode.append(fore) i.blo.append(fore) if len(inode) == 3: index_block = distribute_block() # 申请新的块作为索引块 block[index_block] = [] # 索引块中储存索引 inode.append([index_block, []]) # [1, [2, 3, 4]] elif len(inode) &lt;= 6: # 一级索引 k = inode[-1] # 最后的一个 if len(k[-1]) &lt; 3 or not k[-1]: add_date_block(k, i) else: # 该块已满 add_index_block(inode, i, 1) if len(inode) == 6 and len(inode[-1][-1]) == 3: index_block = distribute_block() inode.append([index_block, []]) # [5, # k: [15,[[6, [7, 8, 9]], # [10, [11, 12, 13]], # kk: [14, [...]]] elif len(inode) &lt;= 9: # 二级索引 if not inode[-1][-1]: index_block = distribute_block() inode[-1][-1] = [[index_block, []]] k = inode[-1][-1] kk = k[-1] # print(k) if len(k) &lt;= 3: # print(kk[-1]) if len(kk[-1]) &lt; 3: add_date_block(kk, i) elif len(kk[-1]) == 3: if len(k) &lt; 3: add_index_block(k, i, 1) else: index_block = distribute_block() inode.append([index_block, []]) add_index_block(inode[-1][-1], i, 0) # print(inode) else: # 当前索引块已满 index_block = distribute_block() inode.append([index_block, []]) add_index_block(inode[-1][-1], i, 0) # print(inode[-1][-1][-1][-1]) if len(inode) == 9 and len(inode[-1][-1][-1][-1]) == 3: index_block = distribute_block() inode.append([index_block, []]) # [5, # k: [15,[[6, [7, 8, 9]], # [10, [11, 12, 13]], # kk: [14, [...]]] elif len(inode) &lt;= 9: # 二级索引 if not inode[-1][-1]: index_block = distribute_block() inode[-1][-1] = [[index_block, []]] k = inode[-1][-1] kk = k[-1] # print(k) if len(k) &lt;= 3: # print(kk[-1]) if len(kk[-1]) &lt; 3: add_date_block(kk, i) elif len(kk[-1]) == 3: if len(k) &lt; 3: add_index_block(k, i, 1) else: index_block = distribute_block() inode.append([index_block, []]) add_index_block(inode[-1][-1], i, 0) # print(inode) else: # 当前索引块已满 index_block = distribute_block() inode.append([index_block, []]) add_index_block(inode[-1][-1], i, 0) # print(inode[-1][-1][-1][-1]) if len(inode) == 9 and len(inode[-1][-1][-1][-1]) == 3: index_block = distribute_block() inode.append([index_block, []]) # [1, [[2, [[3, [4, 5, 6], # [7, [8, 9, 10], # [11,[12,13,14]]] # [15,[[...] else: # 三级索引 if not inode[-1][-1]: index_block = distribute_block() inode[-1][-1] = [[index_block, []]] if not inode[-1][-1][-1]: index_block = distribute_block() inode[-1][-1][-1] = [[index_block, []]] if not inode[-1][-1][-1][-1]: index_block = distribute_block() inode[-1][-1][-1][-1] = [[index_block, []]] if not inode[-1][-1][-1][-1][-1]: index_block = distribute_block() inode[-1][-1][-1][-1][-1] = [[index_block, []]] a = inode[-1][-1] k = a[-1] kk = k[-1] kkk = kk[-1] print(a) if len(a) &lt;= 3: if len(kk) &lt;= 3: print('kkk' + str(kkk)) if len(kkk[-1]) &lt; 3 or not kkk[-1]: print(222) add_date_block(kkk, i) elif len(kkk[-1]) == 3: print(111) print(k) # if len(a) &lt; 3: if len(kk) &lt; 3: add_index_block(kk, i, 1) else: index_block = distribute_block() inode[-1][-1].append([index_block, []]) add_index_block(inode[-1][-1][-1][-1], i, 0) # else: else: # k满了 index_block = distribute_block() inode.append([index_block, []]) add_index_block(inode[-1][-1][-1][-1], i, 0) else: passdef create_file(name, length, doc): # doc:当前目录的inode if name not in doc.file: if sup.unused_block &gt;= length: # 如果有足够的空闲的块 t = time.asctime(time.localtime(time.time())) i = INode(0) inode_table.append(i) # 新建的inode加入列表 global inode doc.file[name] = inode_table.index(i) i.id = inode_table.index(i) i.size = length i.time = t for j in range(length): distribute(i) # print(i.blo) add_tree(name, i.id) else: print('没有足够的空间！') else: print('文件已存在！') return docdef create_doc(name, doc): if name not in doc.file: if sup.unused_block &gt;= 1: t = time.asctime(time.localtime(time.time())) i = INode(1) inode_table.append(i) doc.file[name] = inode_table.index(i) i.id = inode_table.index(i) i.size = 1 i.time = t distribute(i) add_tree(name, i.id) else: print('没有足够的空间！') else: print('文件已存在！') return docdef change_doc(name, doc): global inode_table if name != '..': try: blo = doc.file[name] # 该路径所占的inode块号 blo = inode_table[blo] # 当前路径的inode if blo.type == 1: # 说明是路径 global now_spr, now now_spr += '/' + name # print(now.date) if now.left.date == name: now = now.left else: # l = now n = now.left while n is not None: if n.date == name: break # l = n n = n.right if n.date == name: now = n # print(blo.file) return blo else: # 有该名称的文件，但不是目录 print('不存在该路径！') except KeyError: print('不存在该路径！') else: if now.date == 'root': return doc # print(now.date) now = now.parent i = inode_table[now.inode_num] # print(now.inode_num) now_spr = '/'.join(now_spr.split('/')[:-1]) return idef ls(doc): for i in doc: ino = inode_table[doc[i]] type = '' if ino.type == 1: type = '&lt;dir&gt;' print("%10s %8s %10s %5d" % (ino.time, type, i, ino.size))def remove(name, doc): global sup if name in doc.file: blo = doc.file[name] # inode号 blo = inode_table[blo].blo # 所占的块号 if blo.type == 0 or (blo.type == 1 and not blo.file): del doc.file[name] for i in blo: if sup.table[0] != 10: print(sup.table) sup.table[-1].insert(0, i) sup.table[0] += 1 else: print(sup.table) sup.table[0] = 1 sup.table[-1] = [[10, sup.table[-1]]] else: print('无法删除！') else: print('没有该文件！')if __name__ == '__main__': all, block_size = 500000, 1024 num = math.ceil(all / block_size) block = [-1] * int(num) sup = SuperBlock() sup.initial(num) i = INode(1) # 当前目录的inode i.blo = 0 i.size = 1 i.time = time.asctime(time.localtime(time.time())) inode_table.append(i) sup.table[0] -= 1 sup.table[-1].pop(0) block[0] = -2 root = Tree('root', 0) now = root now_spr = 'root' inode = [] # while True: command = input(now_spr+'/$ ').split() try: if command[0] == 'mkdir': create_doc(command[1], i) elif command[0] == 'cd': i = change_doc(command[1], i) elif command[0] == 'rm': remove(command[1], i) elif command[0] == 'mk': create_file(command[1], math.ceil(int(command[2])/block_size), i) elif command[0] == 'ls': print(inode) ls(i.file) elif command[0] == 'tree': print(now.level*' '+now.date) preorder(now.left) print() else: print('没有该命令！') except Exception: print('没有该命令！') # print(Exception)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分页式存储管理]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%88%86%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[要求：在第1部分实验基础上实现进程的分页式内存分配和地址转换过程，并进一步实现请求分页式存储分配和地址转换过程。页面置换算法至少应实现先进先出（FIFO）、最近最久未使用（LRU）等算法。 建立1个位示图，用来模拟内存的分配情况，位示图的位数与设定的物理块个数相同。程序启动时可利用一组随机0和1填充位示图，表示内存已被占用情况。 1、创建进程时输入进程大小，并根据程序中设定的物理块大小为进程分配物理块，同时建立页表。例如，在上图基础上，若要建立一个大小为5000字节的进程，则： 计算出该进程共有“向上取整（5000/1024）=5”个页，需要占用5个内存块； 建立空的页表，即长度为5的一维整数数组； 从位示图中找出前5个“0”位在整个位示图中的位置号（即i字节j位为0，则该位的位置为8*i+j），并将这些号依次填入页表中，同时把前5个“0”改为“1”，以示对应内存块已经分配。 输入当前执行进程所要访问的逻辑地址，并将其转换成相应的物理地址。 进程退出时，根据其页表内容向位示图反向回填“0”。 扩充页表，将其变成支持请求和置换功能的二维页表（增加存在位等）。创建进程时可装入固定的前三页（或键盘输入初始装入页数，不同进程的装入个数可以不同），其余页装入到置换空间内（置换空间大小应为内存空间大小的1.5-2倍，对其还需建立独立的置换空间位示图）。 分别采用FIFO或LRU置换算法对地址转换过程中遇到的缺页现象进行页面置换，可将多次地址转换过程中所涉及到的页号视为进程的页面访问序列，从而计算置换次数和缺页率。 在完成第六步的基础上实现OPT的页面置换算法，并加以比较。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306import numpy as npimport mathclass PCB(object): def __init__(self, name, length): self.name = name self.length = length self.start = 0 self.page = 0 self.pages_in_ram = 0 self.page_list_FIFO = [[], []] # 页表 self.page_list_LRU = [[], []] self.ram_list_FIFO = [] # 在内存的进程的页表 self.ram_list_LRU = [] self.ram_FIFO = [] self.ram_LRU = [] self.visit = [] # 访问过的页 self.total = 0 self.missing_FIFO = 0 self.missing_LRU = 0 self.swap = [] def show(self): print(self.ram_list_FIFO)def create(p, ready, run): global name_list l = len(name_list) name_list[p.name] = 1 if l == len(name_list): print('不能创建同名进程！') return p.page = math.ceil(p.length / (block_size * 1024)) # 向上取整得页数 p.page_list_FIFO[0] = [0] * p.page p.page_list_FIFO[1] = [0] * p.page p.page_list_LRU[0] = [0] * p.page p.page_list_LRU[1] = [0] * p.page # print(p.page, p.page_list) pages = int(input('进程共有'+str(p.page)+'页, '+'输入装入内存的页数：')) p.pages_in_ram = pages global ram global switch c = 0 if ram.shape[0] * ram.shape[1] - np.count_nonzero(ram) &gt;= pages: # 空闲空间比用户要求的页表大 for i in range(ram.shape[0]): for j in range(ram.shape[1]): if ram[i][j] == 0: ram[i][j] = 1 p.ram_FIFO.append(8 * i + j) p.ram_LRU.append(8 * i + j) c += 1 # 空出pages页给进程 if c &gt;= pages: break if c &gt;= pages: break c = 0 for i in range(switch.shape[0]): for j in range(switch.shape[1]): if switch[i][j] == 0: p.page_list_LRU[0][c] = 8 * i + j # 将进程存入置换空间 p.page_list_FIFO[0][c] = 8 * i + j p.swap.append(8 * i + j) switch[i][j] = 1 c += 1 if c &gt;= p.page: break if c &gt;= p.page: break ready_to_run(ready, run) print(p.page_list_FIFO) else: print('剩余内容不足!剩余块数为:' + str(ram.shape[0] * ram.shape[1] - np.count_nonzero(ram))) print('...正在将剩余内存分配给该进程...')def ready_to_run(ready, run): # print(type(run)) if not run and ready: p = ready.pop(0) # print(type(p)) run.append(p) # print(ready, run)def block(ready, blo, run): if run: pro = run.pop() blo.append(pro) ready_to_run(ready, run) else: print('没有可以阻塞的进程！')def times_over(run, ready): if run: pro = run.pop() ready.append(pro) ready_to_run(ready, run) else: print('没有正在运行的进程！')def wake_up(blo, ready, run): # block[0]-&gt;ready if blo: pro = blo.pop(0) ready.append(pro) ready_to_run(ready, run) else: print('没有可唤醒的进程！')def address_switch(log, p): global block_size page_num = log // (block_size * 1024) # 访问的页号 if page_num &lt; len(p.page_list_FIFO[0]): # log // (block_size * 1024)为页号 p.total += 1 # if p.page_list[1][page_num]: # 如果在内存就转换地址 if len(p.ram_list_FIFO) &lt; p.pages_in_ram: # 如果内存没满，ram列表不为空 if page_num not in p.ram_list_FIFO: # 不在内存 p.missing_FIFO += 1 p.ram_list_FIFO.append(page_num) p.page_list_FIFO[0][page_num] = p.ram_FIFO.pop() # 将属于进程的内存分一块给访问的页 p.page_list_FIFO[1][page_num] = 1 if page_num in p.ram_list_LRU: # 如果在内存，更新位置 # print('!!!!') i = p.ram_list_LRU.index(page_num) p.ram_list_LRU.pop(i) p.ram_list_LRU.append(page_num) if page_num not in p.ram_list_LRU: p.missing_LRU += 1 p.ram_list_LRU.append(page_num) p.page_list_LRU[0][page_num] = p.ram_LRU.pop() p.page_list_LRU[1][page_num] = 1 else: if page_num not in p.ram_list_FIFO: p.missing_FIFO += 1 first = p.ram_list_FIFO.pop(0) # 先进的页号 p.ram_list_FIFO.append(page_num) # 交换出去的和进来的页数在内存和置换空间的位置 p.page_list_FIFO[0][page_num], p.page_list_FIFO[0][first] = p.page_list_FIFO[0][first], \ p.page_list_FIFO[0][page_num] p.page_list_FIFO[1][page_num] = 1 p.page_list_FIFO[1][first] = 0 if page_num in p.ram_list_LRU: # 如果当前页数在内存里 i = p.ram_list_LRU.index(page_num) p.ram_list_LRU.pop(i) p.ram_list_LRU.append(page_num) else: p.missing_LRU += 1 before = p.ram_list_LRU.pop(0) # print('before:', before) p.ram_list_LRU.append(page_num) # 交换出去的和进来的页数在内存和置换空间的位置 p.page_list_LRU[0][page_num], p.page_list_LRU[0][before] = p.page_list_LRU[0][before], \ p.page_list_LRU[0][page_num] p.page_list_LRU[1][page_num] = 1 p.page_list_LRU[1][before] = 0 p.visit.append(page_num) page_FIFO = p.page_list_FIFO[0][page_num] page_add_FIFO = log % (block_size * 1024) page_LRU = p.page_list_LRU[0][page_num] page_add_LRU = log % (block_size * 1024) # print(page_FIFO, page_add_FIFO) print('FIFO:', p.page_list_FIFO) print('FIFO:', p.ram_list_FIFO) print('FIFO下的物理地址:' + str(hex(page_FIFO * block_size * 1024 + page_add_FIFO))) print('FIFO缺页率:' + str(p.missing_FIFO/p.total)) print('LRU:', p.page_list_LRU) print('LRU:', p.ram_list_LRU) print('LRU下的物理地址:' + str(hex(page_LRU * block_size * 1024 + page_add_LRU))) print('LRU缺页率:' + str(p.missing_LRU / p.total)) print('访问列表:', p.visit) # print('OPT缺页率:', opt(p)) else: print('地址越界！')def opt(p): farthest = &#123;&#125; for i in range(p.page): farthest[i] = 0 ram_list = p.visit[:p.pages_in_ram] missing = p.pages_in_ram for i in range(p.pages_in_ram, len(p.visit)): # print(ram_list) for k in range(p.page): try: farthest[k] = p.visit.index(k, i+1, len(p.visit)-1) except ValueError: farthest[k] = 1000 now = p.visit[i] # print(now) # print(farthest) if now not in ram_list: # print('缺页！') missing += 1 far = max(ram_list, key=lambda x: farthest[x]) # 找到最远的页数 ind = ram_list.index(far) ram_list[ind] = now # 将最远的页数替换成现在访问的页数 return missing / p.totaldef quit(ready, run): p = run.pop() global name_list del name_list[p.name] for k in range(len(p.page_list_FIFO[0])): i = p.page_list_FIFO[0][k] // 8 j = p.page_list_FIFO[0][k] % 8 if p.page_list_FIFO[1][k] == 1: global ram ram[i][j] = 0 # 退出时将在内存的页在位示图置零 else: global switch switch[i][j] = 0 # 不再内存的页在置换空间中置零 i = p.page_list_LRU[0][k] // 8 j = p.page_list_LRU[0][k] % 8 if p.page_list_LRU[1][k] == 1: ram[i][j] = 0 # 退出时将在内存的页在位示图置零 else: switch[i][j] = 0 # 不再内存的页在置换空间中置零 for k in range(len(p.swap)): # 统一归还置换空间的位置 i = p.swap[k] // 8 j = p.swap[k] % 8 switch[i][j] = 0 ready_to_run(ready, run)if __name__ == '__main__': run = [] ready = [] blocked = [] while True: try: ram_size = int(input("输入内存(K):")) block_size = int(input("块的大小(K):")) break except ValueError: print('输入错误！请重新输入！') continue ram = np.random.randint(0, 2, (ram_size // (block_size * 8), 8), dtype=np.int8) # 位示图 switch = np.random.randint(0, 2, size=[(ram_size * 2) // (block_size * 8), 8], dtype=np.int8) name_list = &#123;&#125; print("0.输出进程") print("1.创建进程") print("2.进入阻塞状态") print("3.时间片完") print("4.唤醒") print("5.结束进程") print("6.显示位示图") print("7.地址转换") print('8.OPT缺页率') print("9.帮助") print("10.退出") while True: try: a = int(input()) except ValueError: print('输入错误！请重新输入！') continue if a == 0: pass if a == 1: pcb_name, pcb_size = input("输入进程的名字及内存(字节):").strip().split() pcb_size = int(pcb_size) # print(ram) pcb = PCB(pcb_name, pcb_size) ready.append(pcb) create(pcb, ready, run) if a == 2: block(ready, blocked, run) if a == 3: times_over(run, ready) if a == 4: wake_up(blocked, ready, run) if a == 5: quit(ready, run) if a == 6: print('内存位示图:\n', ram) print('置换空间位示图:\n', switch) if a == 7: pcb = run[0] log = int('0x' + input("输入逻辑地址:"), 16) address_switch(log, pcb) if a == 8: pcb = run[0] print(opt(pcb)) if a == 9: print("0.输出进程") print("1.创建进程") print("2.进入阻塞状态") print("3.时间片完") print("4.唤醒") print("5.结束进程") print("6.显示位示图") print("7.地址转换") print('8.OPT缺页率') print("9.帮助") print("10.退出") if a == 10: exit(0)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N后问题]]></title>
    <url>%2F2018%2F04%2F27%2FN%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。 问题算法123456789101112131415161718192021222324# coding=utf-8def place(k, x): for j in range(1, k): if abs(k-j) == abs(x[j]-x[k]) or x[j] == x[k]: return False return Truedef backtrack(t, n, x): if t &gt; n: print(x) else: for i in range(1, n+1): x[t] = i if place(t, x): # 判断i列是否可行 backtrack(t+1, n, x)if __name__ == '__main__': n = int(input("输入皇后个数：")) x = [0] * (n + 1) backtrack(1, n, x)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子段和]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930# coding=utf-8def max_sum(s, ends, starts=0): b = [s[starts]] max = s[starts] start = starts end = ends j = starts + 1 for i in range(1, ends-starts+1): if s[j] &gt; b[i-1]+s[j]: start = j b.append(s[j]) elif s[j] &lt; b[i-1]+s[j]: b.append(b[i-1]+s[j]) if max &lt; b[i]: max = b[i] end = j j += 1 if max &lt; 0: start = end = -1 max = 0 return "起始位置:",start, " 结束位置:",end, " 最大子段和：",maxif __name__ == '__main__': list = list(map(int, input("输入数组，输出最大子段和：").strip().split())) starts = int(input("输入开始位置：")) ends = int(input("输入结束位置：")) print(max_sum(list, ends, starts))]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程控制]]></title>
    <url>%2F2018%2F04%2F27%2F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[要求：利用简单的结构和控制方法模拟进程结构、进程状态和进程控制。 提示：用PCB表示整个进程实体，利用随机数方法或键盘控制方法模拟进程执行中产生的事件，或者利用基于图形界面的鼠标或者键盘操作控制进程管理内容。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191MAX = 0ram_list = []class PCB(object): def __init__(self, name, length): self.name = name self.length = length self.start = 0def distribution(p): sorted(ram_list, key=lambda s: s[1]) # site = 0 for i in range(len(ram_list)): # 找到第一个空闲比他大的位置 if ram_list[i][1] &gt;= p.length: p.start = ram_list[i][0] ram_list[i][0] += p.length # 空闲的起始忘后挪 ram_list[i][1] -= p.length if ram_list[i][1] &lt;= 2: p.length += ram_list[i][1] ram_list.pop(i) global MAX if ram_list: MAX = max(ram_list, key=lambda s: s[1])[1] else: MAX = 0 # print(MAX) # print(ram_list) # site = i breakdef create(ready, run, p): global name_list l = len(name_list) name_list[p.name] = 1 if l == len(name_list): print('不能创建同名进程！') return if p.length &gt; max(ram_list, key=lambda s: s[1])[1]: print('内存不足！') return ready.append(p) ready_to_run(ready, run) distribution(p)def ready_to_run(ready, run): # print(type(run)) if not run and ready: p = ready.pop(0) # print(type(p)) run.append(p) # print(ready, run)def block(ready, blo, run): if run: pro = run.pop() blo.append(pro) ready_to_run(ready, run) else: print('没有可以阻塞的进程！')def times_over(run, ready): if run: pro = run.pop() ready.append(pro) ready_to_run(ready, run) else: print('没有正在运行的进程！')def wake_up(blo, ready, run): # block[0]-&gt;ready if blo: pro = blo.pop(0) ready.append(pro) ready_to_run(ready, run) else: print('没有可唤醒的进程！')def exit(run, ready): sorted(ram_list, key=lambda x: x[0]) if run: p = run.pop() ready_to_run(ready, run) del name_list[p.name] site = 0 # p = (p.start, p.length) # print(ram_list) for i in range(len(ram_list)): # 检查前面 end = ram_list[i][0] + ram_list[i][1] if end == p.start: site = i + 1 break if end &gt; p.start: site = i break ram_list.insert(site, [p.start, p.length]) # print(site) # print(ram_list) global MAX MAX = max(ram_list, key=lambda s: s[1])[1] if site - 1 &gt;= 0: if ram_list[site-1][0] + ram_list[site-1][1] == p.start: # 新加的空闲开始和上一个的结束相同 ram_list[site-1][1] += p.length ram_list.pop(site) # 合并 # print(ram_list) MAX = max(ram_list, key=lambda s: s[1])[1] # print(ram_list) # print(site) if site &lt; len(ram_list): if ram_list[site-1][0] + ram_list[site-1][1] == ram_list[site][0]: # 检查下一个 ram_list[site-1][1] += ram_list[site][1] ram_list.pop(site) # print(ram_list) MAX = max(ram_list, key=lambda s: s[1])[1] return return if site + 1 &lt;= len(ram_list) - 1: if ram_list[site][0] + ram_list[site][1] == ram_list[site+1][0]: # 检查下一个 ram_list[site][1] += ram_list[site+1][1] ram_list.pop(site+1) # print(ram_list) # global MAX MAX = max(ram_list, key=lambda s: s[1])[1] return else: print('没有可退出的进程！')def show(list): s = '' for i in list: s += '('+i.name+','+str(i.start)+','+str(i.length)+') ' return sif __name__ == '__main__': ready = [] running = [] blocked = [] name_list = &#123;&#125; strat, length = map(int, input('输入开始的内存及长度:').strip().split()) MAX = length ram_list = [[strat, length]] print("0.输出进程") print("1.创建进程") print("2.进入阻塞状态") print("3.时间片完") print("4.唤醒") print("5.结束进程") print("6.显示内存") print("7.帮助") print("8.退出") while True: a = int(input()) if a == 0: print("ready:", show(ready)) print("running:", show(running)) print('blocked:', show(blocked)) if a == 1: n, l = input("输入进程的名字及内存:").strip().split() l = int(l) p = PCB(n, l) create(ready, running, p) if a == 2: block(ready, blocked, running) if a == 3: times_over(running, ready) if a == 4: wake_up(blocked, ready, running) if a == 5: exit(running, ready) if a == 6: print(sorted(ram_list, key=lambda s: s[0])) if a == 7: print("0.输出进程") print("1.创建进程") print("2.进入阻塞状态") print("3.时间片完") print("4.唤醒") print("5.结束进程") print("6.显示内存") print("7.帮助") print("8.退出") if a == 8: break]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hermite]]></title>
    <url>%2F2018%2F04%2F27%2FHermite%2F</url>
    <content type="text"><![CDATA[Hermite插值多项式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import matplotlibmatplotlib.use('TkAgg')import matplotlib.pyplot as pltimport numpy as npimport mathdef l(x, x1, k): n = 1.0 for j in range(len(x)): if j != k: n *= (x1 - x[j])/(x[k] - x[j]) return n*ndef l1(x, j): n = 0.0 for k in range(len(x)): if k != j: n += 1.0/(x[j] - x[k]) return ndef hermite(x, y, m, x1): n = 0.0 for j in range(len(x)): a = (1 - 2 * (x1 - x[j]) * l1(x, j)) * l(x, x1, j) b = (x1 - x[j])*l(x, x1, j) n += y[j] * a + m[j] * b return nif __name__ == '__main__': x = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], np.float32) y = np.array([0.904837, 0.818731, 0.740818, 0.670320, 0.606531, 0.548812, 0.496585, 0.449329, 0.406570, 0.367879], np.float32) m = np.array([-0.904837, -0.818731, -0.740818, -0.670320, -0.606531, -0.548812, -0.496585, -0.449329, -0.406570, -0.367879], np.float32) print(hermite(x, y, m, 0.55)) a = [] for i in range(100): a.append(i*0.01) # print(a) # print(a) b = [hermite(x, y, m, i) for i in a] # print(hermite(x, y, m, 3)) plt.figure("play") ax1 = plt.subplot(211) plt.sca(ax1) # plt.plot(x, y, linestyle=' ', marker='o', color='b') plt.plot(a, b, linestyle='--', color='r') plt.show()]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复化求积公式]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%A4%8D%E5%8C%96%E6%B1%82%E7%A7%AF%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839import matplotlibmatplotlib.use('TkAgg') # Mac上这样才能用matplotlibimport matplotlib.pyplot as pltimport numpy as npimport mathdef func(x): return (math.e ** x) * math.cos(x)def composite_integration_rule(a, b, e): n = 1 h = b - a Tn = (h / 2) * (func(a) + func(b)) Hn = sum([func(a + ((2 * i - 1) * h) / 2) for i in range(1, n+1)]) * h T_2 = 2 * Tn - Hn T2n = (Tn + Hn) / 2 while abs(T2n - Tn) &gt;= e: Tn = T2n n = 2 * n h = h / 2 Hn = sum([func(a + ((2 * i - 1) * h) / 2) for i in range(1, n+1)]) * h T2n = (Tn + Hn) / 2 return n, h, T2nif __name__ == '__main__': a = 0 n, h, T2n = composite_integration_rule(0, math.pi, 10 ** (-6)) print(T2n) tmpx = np.arange(0, np.pi, h) plt.plot(tmpx, [func(each) for each in tmpx], linestyle='-', color='black') for rang in range(n): tmpx = [a + h * rang, a + h * rang, a + h * (rang + 1), a + h * (rang + 1)] tmpy = [0, func(tmpx[1]), func(tmpx[2]), 0] c = ['r', 'y', 'b', 'g'] plt.fill(tmpx, tmpy, color=c[rang % 4]) plt.show()]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Least squares]]></title>
    <url>%2F2018%2F04%2F26%2FLeast-squares%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122import matplotlibmatplotlib.use('TkAgg')import matplotlib.pyplot as pltimport numpy as npdef least(x, y, xx): x_y = 0 for i in range(len(x)): x_y += x[i] * y[i] b = (sum([i ** 2 for i in x]) * sum(y) - sum(x) * x_y) / (len(x) * sum([i ** 2 for i in x]) - (sum(x) ** 2)) a = (len(x) * x_y - sum(x) * sum(y)) / (len(x) * sum([i ** 2 for i in x]) - (sum(x) ** 2)) return a * xx + bx = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]y = [68, 67.1, 66.4, 65.6, 64.6, 61.8, 61.0, 60.8, 60.4, 60]xx = [i for i in range(100)]yy = [least(x, y, i) for i in xx]print(least(x, y, 55))plt.plot(xx, yy)plt.show()]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
</search>
